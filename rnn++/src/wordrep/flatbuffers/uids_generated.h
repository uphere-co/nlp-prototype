// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_UIDS_WORDREP_IO_H_
#define FLATBUFFERS_GENERATED_UIDS_WORDREP_IO_H_

#include "flatbuffers/flatbuffers.h"

namespace wordrep {
namespace io {

struct UID;

struct SortedUIDs;

MANUALLY_ALIGNED_STRUCT(8) UID FLATBUFFERS_FINAL_CLASS {
 private:
  int64_t uid_;
  uint32_t name_beg_;
  uint32_t name_end_;

 public:
  UID() {
    memset(this, 0, sizeof(UID));
  }
  UID(const UID &_o) {
    memcpy(this, &_o, sizeof(UID));
  }
  UID(int64_t _uid, uint32_t _name_beg, uint32_t _name_end)
      : uid_(flatbuffers::EndianScalar(_uid)),
        name_beg_(flatbuffers::EndianScalar(_name_beg)),
        name_end_(flatbuffers::EndianScalar(_name_end)) {
  }
  int64_t uid() const {
    return flatbuffers::EndianScalar(uid_);
  }
  uint32_t name_beg() const {
    return flatbuffers::EndianScalar(name_beg_);
  }
  uint32_t name_end() const {
    return flatbuffers::EndianScalar(name_end_);
  }
};
STRUCT_END(UID, 16);

struct SortedUIDs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_UIDS = 4,
    VT_CHARS = 6
  };
  const flatbuffers::Vector<const UID *> *uids() const {
    return GetPointer<const flatbuffers::Vector<const UID *> *>(VT_UIDS);
  }
  const flatbuffers::Vector<uint8_t> *chars() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CHARS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_UIDS) &&
           verifier.Verify(uids()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CHARS) &&
           verifier.Verify(chars()) &&
           verifier.EndTable();
  }
};

struct SortedUIDsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uids(flatbuffers::Offset<flatbuffers::Vector<const UID *>> uids) {
    fbb_.AddOffset(SortedUIDs::VT_UIDS, uids);
  }
  void add_chars(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> chars) {
    fbb_.AddOffset(SortedUIDs::VT_CHARS, chars);
  }
  SortedUIDsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SortedUIDsBuilder &operator=(const SortedUIDsBuilder &);
  flatbuffers::Offset<SortedUIDs> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<SortedUIDs>(end);
    return o;
  }
};

inline flatbuffers::Offset<SortedUIDs> CreateSortedUIDs(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const UID *>> uids = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> chars = 0) {
  SortedUIDsBuilder builder_(_fbb);
  builder_.add_chars(chars);
  builder_.add_uids(uids);
  return builder_.Finish();
}

inline flatbuffers::Offset<SortedUIDs> CreateSortedUIDsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<const UID *> *uids = nullptr,
    const std::vector<uint8_t> *chars = nullptr) {
  return wordrep::io::CreateSortedUIDs(
      _fbb,
      uids ? _fbb.CreateVector<const UID *>(*uids) : 0,
      chars ? _fbb.CreateVector<uint8_t>(*chars) : 0);
}

inline const wordrep::io::SortedUIDs *GetSortedUIDs(const void *buf) {
  return flatbuffers::GetRoot<wordrep::io::SortedUIDs>(buf);
}

inline const char *SortedUIDsIdentifier() {
  return "wfsu";
}

inline bool SortedUIDsBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, SortedUIDsIdentifier());
}

inline bool VerifySortedUIDsBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<wordrep::io::SortedUIDs>(SortedUIDsIdentifier());
}

inline const char *SortedUIDsExtension() {
  return "wfsu";
}

inline void FinishSortedUIDsBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<wordrep::io::SortedUIDs> root) {
  fbb.Finish(root, SortedUIDsIdentifier());
}

}  // namespace io
}  // namespace wordrep

#endif  // FLATBUFFERS_GENERATED_UIDS_WORDREP_IO_H_
